{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","Promise","response","status","console","log","resolve","reject","Error","statusText","offlineFavourites","idb","open","upgradeDb","oldVersion","dbPromise","keyPath","createIndex","store","createObjectStore","reviews","openDB","then","db","transaction","objectStore","getAll","fetch","DATABASE_URL","checkStatus","json","restaurants","saveRestaurants","data","tx","forEach","restaurant","put","complete","getRestaurantsFromAPI","callback","catch","error","fetchRestaurants","find","r","id","cuisine","filter","cuisine_type","results","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","fetchReviews","uniqueCuisines","cuisines","arguments","length","undefined","imgWidth","imageUrlForRestaurant","google","maps","Marker","position","latlng","title","name","Animation","DROP","index","saveReviews","err","imageSrcSet","review","event","CustomEvent","detail","restaurant_id","document","reviewsFromDB","reviewsFromAPI","REVIEWS_URL","body","JSON","stringify","headers","Accept","Content-Type","method","parseInt","getParameterByName","Date","getTime","saveReview","saveReviewOffline","requests","iterateCursor","cursor","sendReview","value","push","delete","continue","dispatchEvent","getReviewsFromAPI","obj","favourite_status","updateRestaurant","sendFavourite","is_favorite"],"mappings":"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","file":"dbhelper.js","sourcesContent":["class DBHelper {\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Get Reviews Endpoint.\r\n   */\r\n  static get REVIEWS_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/reviews`;\r\n  }\r\n\r\n  /**\r\n   * Check status of Fetch requests.\r\n   */\r\n  static checkStatus(response) {\r\n    if (response.status === 200) {\r\n      console.log(status);\r\n      return Promise.resolve(response)\r\n    } else {\r\n      return Promise.reject(new Error(`Request has failed. Return status: ${response.statusText}`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert response to JSON data.\r\n   */\r\n  static json(response) {\r\n    return response.json()\r\n  }\r\n\r\n  /**\r\n   * Opens the IndexedDB.\r\n   */\r\n  static openDB() {\r\n    const dbPromise = idb.open('restaurantsDB', 1, upgradeDb => {\r\n      switch (upgradeDb.oldVersion) {\r\n        case 0:\r\n          console.log('Creating IDB');\r\n          const store = upgradeDb.createObjectStore('restaurants', {keyPath: 'id'});\r\n          store.createIndex('by-id', 'id');\r\n        case 1:\r\n          console.log(\"Upgrading to DB v2\");\r\n          const reviews = upgradeDb.createObjectStore('reviews', {keyPath: 'id'});\r\n          reviews.createIndex('restaurant','restaurant_id');\r\n          const offlineReviews = upgradeDb.createObjectStore('offline_reviews', {keyPath: 'updatedAt'});\r\n        case 2:\r\n          console.log(\"Upgrading to DB v3\");\r\n          const offlineFavourites = upgradeDb.createObjectStore('offline_favourites', {keyPath: 'restaurant_id'});\r\n          offlineFavourites.createIndex('by-restaurant', 'restaurant_id');\r\n      }\r\n    });\r\n    return dbPromise;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the IDB.\r\n   */\r\n  static getRestaurantsFromDB() {\r\n    const restaurantsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('restaurants').objectStore('restaurants');\r\n      return store.getAll();\r\n    });\r\n    return restaurantsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the Server API.\r\n   */\r\n  static getRestaurantsFromAPI(){\r\n    const restaurantsFromAPI = fetch(DBHelper.DATABASE_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(restaurants => {\r\n      DBHelper.saveRestaurants(restaurants);\r\n      return restaurants;\r\n    });\r\n    return restaurantsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Save restaurants data to IDB.\r\n   */\r\n  static saveRestaurants(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      data.forEach((restaurant) => {\r\n        store.put(restaurant);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Restaurants Saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update restaurant data to IDB.\r\n   */\r\n  static updateRestaurant(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      return store.put(data);\r\n    }).then(() => {\r\n      console.log('Restaurant Updated')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n      if(restaurants.length) {\r\n        return Promise.resolve(restaurants);\r\n      } else {\r\n        return DBHelper.getRestaurantsFromAPI();\r\n      }\r\n    }).then(restaurants => {\r\n      callback(null, restaurants);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n    DBHelper.fetchReviews((error, reviews) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        //console.log('dbhelper fetchReviews !error()')\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, imgWidth = null) {\r\n    if (imgWidth !== null) {\r\n      return `/build/img/${restaurant.id}-${imgWidth}.jpg`;\r\n    }\r\n    return `/build/img/${restaurant.id}-original.jpg`;\r\n  }\r\n\r\n  /**\r\n   * Restaurant image SRCSET.\r\n   */\r\n  static imageSrcSetForRestaurant(restaurant) {\r\n    const widthXsmall   = DBHelper.imageUrlForRestaurant(restaurant, 'xsmall');\r\n    const widthSmall    = DBHelper.imageUrlForRestaurant(restaurant, 'small');\r\n    const widthMedium   = DBHelper.imageUrlForRestaurant(restaurant, 'medium');\r\n    const widthLarge    = DBHelper.imageUrlForRestaurant(restaurant, 'large');\r\n    const widthOriginal = DBHelper.imageUrlForRestaurant(restaurant);\r\n    const imageSrcSet = `${widthXsmall} 360w, ${widthSmall} 520w, ${widthMedium} 800w, ${widthLarge} 1000w, ${widthOriginal} 1500w`;\r\n    return imageSrcSet;\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the IDB.\r\n   */\r\n  static getReviewsFromDB() {\r\n    const reviewsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('reviews').objectStore('reviews').index('restaurant');\r\n      return '';//store.getAll();\r\n    });\r\n    return reviewsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the Server API.\r\n   */\r\n  static getReviewsFromAPI(){\r\n    const reviewsFromAPI = fetch(DBHelper.REVIEWS_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(reviews => {\r\n      DBHelper.saveReviews(reviews);\r\n      return reviews;\r\n    });\r\n    return reviewsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews saved as Offline.\r\n   */\r\n  static checkOfflineReviews(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_reviews').objectStore('offline_reviews');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Save Reviews data to IDB.\r\n   */\r\n  static saveReviews(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      data.forEach((review) => {\r\n        store.put(review);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Reviews saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB.\r\n   */\r\n  static saveReview(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved')\r\n      let event = new CustomEvent(\"update_reviews_list\", {detail: {restaurant_id: data.restaurant_id}});\r\n      document.dispatchEvent(event);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB's offline store.\r\n   */\r\n  static saveReviewOffline(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_reviews', 'readwrite');\r\n      const store = tx.objectStore('offline_reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendReview(data) {\r\n    return fetch(DBHelper.REVIEWS_URL, {\r\n      body: JSON.stringify(data),\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json'\r\n      },\r\n      method: 'POST',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n        data['updatedAt'] = new Date().getTime();\r\n        data['createdAt'] = new Date().getTime();\r\n        DBHelper.saveReview(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n      data['updatedAt'] = new Date().getTime();\r\n      data['createdAt'] = new Date().getTime();\r\n      DBHelper.saveReviewOffline(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Reviews and send them to server.\r\n   */\r\n  static removeOfflineReview(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_reviews', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_reviews')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendReview(cursor.value)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Item deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch all reviews.\r\n   */\r\n  static fetchReviews(callback) {\r\n    return DBHelper.getReviewsFromDB().then(reviews => {\r\n      if(reviews.length) {\r\n        return Promise.resolve(reviews);\r\n      } else {\r\n        return DBHelper.getReviewsFromAPI();\r\n      }\r\n    }).then(reviews => {\r\n      callback(null, reviews);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews by its ID.\r\n   */\r\n  static fetchReviewByRestaurant(id, callback) {\r\n    return DBHelper.openDB().then(db => {\r\n      return db.transaction('reviews').objectStore('reviews').index('restaurant').getAll(id);\r\n    }).then(obj => {\r\n      return obj\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Favourite data to IDB's offline store.\r\n   */\r\n  static saveFavouriteOffline(id, favourite_status){\r\n    const data = []\r\n    data['restaurant_id'] = parseInt(id);\r\n    data['is_favorite'] = favourite_status;\r\n\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_favourites', 'readwrite');\r\n      const store = tx.objectStore('offline_favourites');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Favourite saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendFavourite(id, favourite_status) {\r\n    let UPDATE_FAV_URL = `${DBHelper.DATABASE_URL}/${id}/?is_favorite=${favourite_status}`\r\n\r\n    return fetch(UPDATE_FAV_URL, {\r\n      method: 'PUT',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        DBHelper.updateRestaurant(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      DBHelper.saveFavouriteOffline(id, favourite_status);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the Favourites saved as Offline.\r\n   */\r\n  static checkOfflineFavourites(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_favourites').objectStore('offline_favourites');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Favourites and send them to server.\r\n   */\r\n  static removeOfflineFavourite(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_favourites', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_favourites')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendFavourite(cursor.value.restaurant_id, cursor.value.is_favorite)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Favourite deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n}"]}