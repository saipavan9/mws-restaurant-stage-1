{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","response","reject","Promise","resolve","Error","statusText","offlineFavourites","idb","open","upgradeDb","oldVersion","dbPromise","keyPath","createIndex","console","store","createObjectStore","reviews","openDB","then","db","log","transaction","objectStore","getAll","fetch","DATABASE_URL","checkStatus","json","restaurants","saveRestaurants","data","tx","forEach","restaurant","put","complete","getRestaurantsFromAPI","callback","catch","error","fetchRestaurants","find","r","id","cuisine","filter","cuisine_type","results","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","fetchReviews","uniqueCuisines","cuisines","arguments","length","undefined","imgWidth","imageUrlForRestaurant","google","maps","Marker","position","title","url","urlForRestaurant","animation","Animation","DROP","index","REVIEWS_URL","saveReviews","widthXsmall","widthSmall","widthMedium","widthLarge","widthOriginal","imageSrcSet","review","event","CustomEvent","detail","restaurant_id","document","reviewsFromDB","reviewsFromAPI","body","JSON","stringify","headers","Accept","Content-Type","method","parseInt","getParameterByName","Date","getTime","saveReview","saveReviewOffline","requests","iterateCursor","cursor","sendReview","value","push","delete","continue","dispatchEvent","getReviewsFromAPI","obj","favourite_status","updateRestaurant","err","sendFavourite","is_favorite"],"mappings":"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","file":"dbhelper.js","sourcesContent":["class DBHelper {\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/restaurants`;\r\n  }\r\n\r\n  /**\r\n   * Get Reviews Endpoint.\r\n   */\r\n  static get REVIEWS_URL() {\r\n    const port = 1337 // Change this to your server port\r\n    return `http://localhost:${port}/reviews`;\r\n  }\r\n\r\n  /**\r\n   * Check status of Fetch requests.\r\n   */\r\n  static checkStatus(response) {\r\n    if (response.status === 200) {\r\n      return Promise.resolve(response)\r\n    } else {\r\n      return Promise.reject(new Error(`Request has failed. Return status: ${response.statusText}`))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert response to JSON data\r\n   */\r\n  static json(response) {\r\n    return response.json()\r\n  }\r\n\r\n  /**\r\n   * Opens the IndexedDB\r\n   */\r\n  static openDB() {\r\n      const dbPromise = idb.open('restaurantsDB', 3, upgradeDb => {\r\n      switch (upgradeDb.oldVersion) {\r\n        case 0:\r\n          console.log('Creating IDB');\r\n          const store = upgradeDb.createObjectStore('restaurants', {keyPath: 'id'});\r\n          store.createIndex('by-id', 'id');\r\n        case 1:\r\n          console.log(\"Upgrading to DB v2\");\r\n          const reviews = upgradeDb.createObjectStore('reviews', {keyPath: 'id'});\r\n          reviews.createIndex('restaurant','restaurant_id');\r\n          const offlineReviews = upgradeDb.createObjectStore('offline_reviews', {keyPath: 'updatedAt'});\r\n        case 2:\r\n          console.log(\"Upgrading to DB v3\");\r\n          const offlineFavourites = upgradeDb.createObjectStore('offline_favourites', {keyPath: 'restaurant_id'});\r\n          offlineFavourites.createIndex('by-restaurant', 'restaurant_id');\r\n      }\r\n    });\r\n    return dbPromise;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the IDB\r\n   */\r\n  static getRestaurantsFromDB() {\r\n    const restaurantsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      console.log('Getting Restaurants From DB');\r\n      if(!db) return;\r\n      let store = db.transaction('restaurants').objectStore('restaurants');\r\n      return store.getAll();\r\n    });\r\n    return restaurantsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Restaurants from the Server API\r\n   */\r\n  static getRestaurantsFromAPI(){\r\n    console.log('Getting Restaurants From API');\r\n    const restaurantsFromAPI = fetch(DBHelper.DATABASE_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(restaurants => {\r\n      DBHelper.saveRestaurants(restaurants);\r\n      return restaurants;\r\n    });\r\n    return restaurantsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Save restaurant data to IDB\r\n   */\r\n  static saveRestaurants(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      data.forEach((restaurant) => {\r\n        store.put(restaurant);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Restaurants Saved')\r\n    });\r\n  }\r\n  /**\r\n   * Update restaurant data to IDB.\r\n   */\r\n  static updateRestaurant(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('restaurants', 'readwrite');\r\n      const store = tx.objectStore('restaurants');\r\n      return store.put(data);\r\n    }).then(() => {\r\n      console.log('Restaurant Updated')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n      if(restaurants.length) {\r\n        return Promise.resolve(restaurants);\r\n      } else {\r\n        return DBHelper.getRestaurantsFromAPI();\r\n      }\r\n    }).then(restaurants => {\r\n      callback(null, restaurants);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n   DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n    DBHelper.fetchReviews((error, reviews) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        //console.log('dbhelper fetchReviews !error()')\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, imgWidth = null) {\r\n    if (imgWidth !== null) {\r\n      return `/build/img/${restaurant.id}-${imgWidth}.jpg`;\r\n    }\r\n    return `/build/img/${restaurant.id}-original.jpg`;\r\n\r\n    //return (`/img/${restaurant.photograph}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image SRCSET.\r\n   */\r\n  static imageSrcSetForRestaurant(restaurant) {\r\n    const widthXsmall   = DBHelper.imageUrlForRestaurant(restaurant, 'xsmall');\r\n    const widthSmall    = DBHelper.imageUrlForRestaurant(restaurant, 'small');\r\n    const widthMedium   = DBHelper.imageUrlForRestaurant(restaurant, 'medium');\r\n    const widthLarge    = DBHelper.imageUrlForRestaurant(restaurant, 'large');\r\n    const widthOriginal = DBHelper.imageUrlForRestaurant(restaurant);\r\n    const imageSrcSet = `${widthXsmall} 360w, ${widthSmall} 520w, ${widthMedium} 800w, ${widthLarge} 1000w, ${widthOriginal} 1500w`;\r\n    return imageSrcSet;\r\n  }\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  //  static mapMarkerForRestaurant(restaurant, map) {\r\n  //   // https://leafletjs.com/reference-1.3.0.html#marker  \r\n  //   const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n  //     {title: restaurant.name,\r\n  //     alt: restaurant.name,\r\n  //     url: DBHelper.urlForRestaurant(restaurant)\r\n  //     })\r\n  //     marker.addTo(newMap);\r\n  //   return marker;\r\n  // } \r\n   static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n   /**\r\n   * Get the Reviews from the IDB.\r\n   */\r\n  static getReviewsFromDB() {\r\n    const reviewsFromDB = DBHelper.openDB()\r\n    .then( db => {\r\n      if(!db) return;\r\n      let store = db.transaction('reviews').objectStore('reviews').index('restaurant');\r\n      return '';//store.getAll();\r\n    });\r\n    return reviewsFromDB;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews from the Server API.\r\n   */\r\n  static getReviewsFromAPI(){\r\n    const reviewsFromAPI = fetch(DBHelper.REVIEWS_URL)\r\n    .then(DBHelper.checkStatus)\r\n    .then(DBHelper.json)\r\n    .then(reviews => {\r\n      DBHelper.saveReviews(reviews);\r\n      return reviews;\r\n    });\r\n    return reviewsFromAPI;\r\n  }\r\n\r\n  /**\r\n   * Get the Reviews saved as Offline.\r\n   */\r\n  static checkOfflineReviews(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_reviews').objectStore('offline_reviews');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Save Reviews data to IDB.\r\n   */\r\n  static saveReviews(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      data.forEach((review) => {\r\n        store.put(review);\r\n      });\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Reviews saved')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB.\r\n   */\r\n  static saveReview(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('reviews', 'readwrite');\r\n      const store = tx.objectStore('reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved')\r\n      let event = new CustomEvent(\"update_reviews_list\", {detail: {restaurant_id: data.restaurant_id}});\r\n      document.dispatchEvent(event);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Review data to IDB's offline store.\r\n   */\r\n  static saveReviewOffline(data){\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_reviews', 'readwrite');\r\n      const store = tx.objectStore('offline_reviews');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Review saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendReview(data) {\r\n    return fetch(DBHelper.REVIEWS_URL, {\r\n      body: JSON.stringify(data),\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Content-Type': 'application/json'\r\n      },\r\n      method: 'POST',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n        data['updatedAt'] = new Date().getTime();\r\n        data['createdAt'] = new Date().getTime();\r\n        DBHelper.saveReview(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n      data['updatedAt'] = new Date().getTime();\r\n      data['createdAt'] = new Date().getTime();\r\n      DBHelper.saveReviewOffline(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Reviews and send them to server.\r\n   */\r\n  static removeOfflineReview(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_reviews', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_reviews')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendReview(cursor.value)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Item deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch all reviews.\r\n   */\r\n  static fetchReviews(callback) {\r\n    return DBHelper.getReviewsFromDB().then(reviews => {\r\n      if(reviews.length) {\r\n        return Promise.resolve(reviews);\r\n      } else {\r\n        return DBHelper.getReviewsFromAPI();\r\n      }\r\n    }).then(reviews => {\r\n      callback(null, reviews);\r\n    }).catch(error => {\r\n      callback(error, null);\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Fetch reviews by its ID.\r\n   */\r\n  static fetchReviewByRestaurant(id, callback) {\r\n    return DBHelper.openDB().then(db => {\r\n      return db.transaction('reviews').objectStore('reviews').index('restaurant').getAll(id);\r\n    }).then(obj => {\r\n      return obj\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Save Favourite data to IDB's offline store.\r\n   */\r\n  static saveFavouriteOffline(id, favourite_status){\r\n    const data = []\r\n    data['restaurant_id'] = parseInt(id);\r\n    data['is_favorite'] = favourite_status;\r\n\r\n    return DBHelper.openDB().then(db => {\r\n      if(!db) return;\r\n      const tx = db.transaction('offline_favourites', 'readwrite');\r\n      const store = tx.objectStore('offline_favourites');\r\n      store.put(data);\r\n      return tx.complete;\r\n    }).then(() => {\r\n      console.log('Favourite saved offline')\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit the restaurant review to server.\r\n   */\r\n  static sendFavourite(id, favourite_status) {\r\n    let UPDATE_FAV_URL = `${DBHelper.DATABASE_URL}/${id}/?is_favorite=${favourite_status}`\r\n\r\n    return fetch(UPDATE_FAV_URL, {\r\n      method: 'PUT',\r\n    })\r\n    .then(response => {\r\n      response.json()\r\n      .then(data => {\r\n        DBHelper.updateRestaurant(data);\r\n      })\r\n    })\r\n    .catch(error => {\r\n      DBHelper.saveFavouriteOffline(id, favourite_status);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the Favourites saved as Offline.\r\n   */\r\n  static checkOfflineFavourites(){\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if(!db) return;\r\n        let store = db.transaction('offline_favourites').objectStore('offline_favourites');\r\n        store.getAll().then(data => {\r\n          return resolve(data);\r\n        }).catch(err => {\r\n          reject(err);\r\n        });\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove Offline Favourites and send them to server.\r\n   */\r\n  static removeOfflineFavourite(data) {\r\n    return new Promise((resolve,reject) => {\r\n      DBHelper.openDB().then(db => {\r\n        if (!db) return;\r\n        const tx = db.transaction('offline_favourites', 'readwrite');\r\n        const requests = [];\r\n\r\n        tx.objectStore('offline_favourites')\r\n        .iterateCursor(cursor => {\r\n          if (!cursor) return;\r\n          DBHelper.sendFavourite(cursor.value.restaurant_id, cursor.value.is_favorite)\r\n          requests.push(cursor.value);\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }).then(() => {\r\n          console.log('Favourite deleted');\r\n        }).then(() => {\r\n          return tx.complete;\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\n"]}