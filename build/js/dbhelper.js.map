{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","callback","xhr","XMLHttpRequest","open","DATABASE_URL","onload","status","restaurants","responseText","error","json","JSON","send","id","fetchRestaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","v","i","neighborhoods","indexOf","uniqueNeighborhoods","cuisines","map","uniqueCuisines","photograph","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap"],"mappings":"iYAGMA,4HAcoBC,GAHxB,IAAAC,EAAA,IAAAC,eAKED,EAAIE,KAAK,MAAOJ,EAASK,cACzBH,EAAII,OAAS,WACX,GAAmB,MAAfJ,EAAIK,OAAgB,CAH1B,IACAC,EADcL,KAAAA,MAAAA,EAAdM,cACyBJ,YACzBH,EAAA,KAAaM,OACPN,CAAsB,IAAAQ,EAAAA,sCAAAR,EAAAK,OACxBN,EAAMU,EAAOC,QAGdV,EAAAW,mDAKHC,EAAAb,GAQAD,EAASe,iBAAiB,SAACL,EAAOF,GALpC,GAAAE,EAOMT,EAASS,EAAO,UACX,CACL,IAAMM,EAAaR,EAAYS,KAAK,SAAAC,GAAA,OAAKA,EAAEJ,IAAMA,IAC7CE,EACFf,EAAS,KAAMe,GAPrBf,EAAA,4BAAA,0DAMsBkB,EAAAlB,GAEjBD,EAFDe,iBAEO,SAAAL,EAAAF,GAAE,GAAAE,EACPT,EAAAA,EAAS,UACV,CATL,IAAAmB,EAAAZ,EAAAa,OAAA,SAAAH,GAAA,OAAAA,EAAAI,cAAAH,IAYDlB,EAAA,KAAAmB,4DAqBoCG,EAActB,GAdjDD,EAAAA,iBAASe,SAATL,EAA0BF,GACxB,GAAAE,EACET,EAAAA,EAAA,UADF,CAIE,IAAMmB,EAAUZ,EAAYa,OAAO,SAAAH,GAAA,OAAAA,EAAAK,cAAAA,IAAAtB,EAAA,KAAOqB,sEAyBDH,EAASI,EAActB,GAEpED,EAASe,iBAAiB,SAACL,EAAOF,GAChC,GAAIE,EACFT,EAASS,EAAO,UACX,CApBT,IAAAU,EAAAZ,EACSO,OAATf,IACEoB,EAAWA,EAAAC,OAAA,SAAAH,GAAA,OAAAA,EAAAI,cAAAH,KAEJ,OAFPI,IAGEH,EAAAA,EAAAC,OAAA,SAAAH,GAAA,OAAAA,EAAAK,cAAAA,KACmCtB,EAAA,KAAOsB,iDA8BtBtB,GAExBD,EAASe,iBAAiB,SAACL,EAAOF,GAChC,GAAIE,EACFT,EAASS,EAAO,UACX,CAxBTV,IAAAA,EAASe,EAAkBL,IAAAA,SAADc,EAAQhB,GAAPE,OAAOF,EAAgBiB,GAAAF,eAE9CtB,EAAAyB,EAAAL,OAAA,SAAAG,EAAAC,GAAA,OAAAC,EAAAC,QAAAH,IAAAC,IACDxB,EAAM,KAAA2B,4CAKDL,GACFH,EAAAA,iBAAkBC,SAAAA,EAAOb,GAAA,GAAAE,EAAAT,EAAzBS,EAAA,UACD,CAEF,IAAAmB,EAAArB,EAAAsB,IAAA,SAAAN,EAAAC,GAAA,OAAAjB,EAAAiB,GAAAH,eAEJS,EAAAF,EAAAR,OAAA,SAAAG,EAAAC,GAAA,OAAAI,EAAAF,QAAAH,IAAAC,IAiCKxB,EAAS,KAAM8B,+CA3BnBf,GACAhB,MAAAA,wBAA0BgB,EAAAF,iDAKsCW,GAAtB,MAAA,QAAtCT,EAAAgB,0DAIDhB,EAAAc,GAEJ,IAAAG,EAAA,IAAAC,EAAAD,OAAA,CAAAjB,EAAAmB,OAAAC,IAAApB,EAAAmB,OAAAE,KAwCG,CAACC,MAAOtB,EAAWuB,KAtCvBC,IAAAxB,EAAAuB,KAwCIE,IAAKzC,EAAS0C,iBAAiB1B,KAGjC,OADEiB,EAAOU,MAAMC,QACRX,uCA3JP,MAAA","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 8000 // Change this to your server port\r\n    return `http://localhost:${port}/data/restaurants.json`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.DATABASE_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const json = JSON.parse(xhr.responseText);\r\n        const restaurants = json.restaurants;\r\n        callback(null, restaurants);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }\r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    return (`/img/${restaurant.photograph}`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n   static mapMarkerForRestaurant(restaurant, map) {\r\n    // https://leafletjs.com/reference-1.3.0.html#marker  \r\n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n      {title: restaurant.name,\r\n      alt: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant)\r\n      })\r\n      marker.addTo(newMap);\r\n    return marker;\r\n  } \r\n  /* static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  } */\r\n\r\n}\r\n\r\n"]}